mod cpu;
mod instructions;

use anyhow::Result;
use cpu::Cpu;
use instructions::Instruction;
use std::{fs, path::PathBuf};

const RAM_SIZE: usize = 4096;
const NUM_REGS: usize = 16;
const START_ADDRESS: u16 = 0x200;
const STACK_SIZE: usize = 16;

pub const SCALE: f32 = 15.;
pub const DISPLAY_WIDTH: usize = 64;
pub const DISPLAY_HEIGHT: usize = 32;
pub const NUM_KEYS: usize = 16;
pub const FONTS_SIZE: usize = 80;
pub const TICKS_PER_FRAME: usize = 10;

const FONTS: [u8; FONTS_SIZE] = [
	0xF0, 0x90, 0x90, 0x90, 0xF0, 0x20, 0x60, 0x20, 0x20, 0x70, 0xF0, 0x10, 0xF0,
	0x80, 0xF0, 0xF0, 0x10, 0xF0, 0x10, 0xF0, 0x90, 0x90, 0xF0, 0x10, 0x10, 0xF0,
	0x80, 0xF0, 0x10, 0xF0, 0xF0, 0x80, 0xF0, 0x90, 0xF0, 0xF0, 0x10, 0x20, 0x40,
	0x40, 0xF0, 0x90, 0xF0, 0x90, 0xF0, 0xF0, 0x90, 0xF0, 0x10, 0xF0, 0xF0, 0x90,
	0xF0, 0x90, 0x90, 0xE0, 0x90, 0xE0, 0x90, 0xE0, 0xF0, 0x80, 0x80, 0x80, 0xF0,
	0xE0, 0x90, 0x90, 0x90, 0xE0, 0xF0, 0x80, 0xF0, 0x80, 0xF0, 0xF0, 0x80, 0xF0,
	0x80, 0x80,
];

const IBM_LOGO: [u8; 132] = [
	0x00, 0xe0, 0xa2, 0x2a, 0x60, 0x0c, 0x61, 0x08, 0xd0, 0x1f, 0x70, 0x09, 0xa2,
	0x39, 0xd0, 0x1f, 0xa2, 0x48, 0x70, 0x08, 0xd0, 0x1f, 0x70, 0x04, 0xa2, 0x57,
	0xd0, 0x1f, 0x70, 0x08, 0xa2, 0x66, 0xd0, 0x1f, 0x70, 0x08, 0xa2, 0x75, 0xd0,
	0x1f, 0x12, 0x28, 0xff, 0x00, 0xff, 0x00, 0x3c, 0x00, 0x3c, 0x00, 0x3c, 0x00,
	0x3c, 0x00, 0xff, 0x00, 0xff, 0xff, 0x00, 0xff, 0x00, 0x38, 0x00, 0x3f, 0x00,
	0x3f, 0x00, 0x38, 0x00, 0xff, 0x00, 0xff, 0x80, 0x00, 0xe0, 0x00, 0xe0, 0x00,
	0x80, 0x00, 0x80, 0x00, 0xe0, 0x00, 0xe0, 0x00, 0x80, 0xf8, 0x00, 0xfc, 0x00,
	0x3e, 0x00, 0x3f, 0x00, 0x3b, 0x00, 0x39, 0x00, 0xf8, 0x00, 0xf8, 0x03, 0x00,
	0x07, 0x00, 0x0f, 0x00, 0xbf, 0x00, 0xfb, 0x00, 0xf3, 0x00, 0xe3, 0x00, 0x43,
	0xe0, 0x00, 0xe0, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0xe0,
	0x00, 0xe0,
];

pub struct Emulator {
	pub running: bool,
	pub cpu: Cpu,
}

impl Emulator {
	pub fn new() -> Self {
		let mut emu = Self {
			running: false,
			cpu: Cpu::default(),
		};
		emu.load_rom_from_bytes(&IBM_LOGO);
		emu
	}

	pub fn start(&mut self) {
		self.running = true;
	}

	pub fn stop(&mut self) {
		self.running = false;
	}

	pub fn tick_timer(&mut self) {
		if self.cpu.delay_timer > 0 {
			self.cpu.delay_timer -= 1;
		}

		if self.cpu.sound_timer > 0 {
			if self.cpu.sound_timer == 1 {
				// beep
			}
			self.cpu.sound_timer -= 1;
		}
	}

	pub fn press_key(&mut self, index: usize, pressed: bool) {
		self.cpu.keys[index] = pressed;
	}

	pub fn load_rom(&mut self, rom: &PathBuf) -> Result<()> {
		let data = fs::read(rom)?;
		self.load_rom_from_bytes(&data);
		Ok(())
	}

	pub fn load_rom_from_bytes(&mut self, data: &[u8]) {
		self.stop();
		let start = START_ADDRESS as usize;
		let end = (START_ADDRESS as usize) + data.len();
		self.cpu.memory[start..end].copy_from_slice(&data);
		self.cpu.reset();
		self.start();
	}
}

impl Default for Emulator {
	fn default() -> Self {
		Self::new()
	}
}
